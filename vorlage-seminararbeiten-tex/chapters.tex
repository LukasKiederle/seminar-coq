\section{Motivation}
{Wenn heutzutage die Spezifikation eines Projektes in Englisch formuliert wird, ist diese Spezifikation von Anfang an mehrdeutig, behauptet Jeannette Wing, Coperate Vice President von Microsoft Research. Des Weiteren sagt sie, dass jede natürliche Sprache mehrdeutig ist. Hingegen in formalen Spezifikationen, wird basierend auf Mathematik präzise erklärt, was genau ein Programm machen soll.}\cite{WING01:FV}
\\
\\
Diese Seminararbeit soll einen tieferen Einblick in den Themenbereich der Programmcodeverifikation schaffen. Dabei wird sowohl auf die Grundlagen als auch technisch-detaillierte Beispiele eingegangen. Als technisches Mittel wird hierfür der Proof-Assistent Coq verwendet.

\begin{itemize}
	\item Normale Software wird so gebaut und evaluiert, sodass sie funktioniert
	\item “If you start with an English-language specification, you’re inherently starting with an ambiguous specification,” said Jeannette Wing, corporate vice president at Microsoft Research. “Any natural language is inherently ambiguous. In a formal specification you’re writing down a precise specification based on mathematics to explain what it is you want the program to do.”
	\item \url{https://www.quantamagazine.org/formal-verification-creates-hacker-proof-code-20160920/}
	\item Fehler 40
	\item Was wenn ein Compiler auf unterschiedlichen System aus dem selben Sourcecode unterschiedliche Runnables macht?
	\item \url{https://www.mikrocontroller.net/articles/Compilerfehler}
	\item \url{https://blog.regehr.org/archives/26}
	\item Unit tests schreiben, um möglichst viele Fehler zu finden -> Proof Assistent um für alle korrekt zu funktionieren
	\item Proof Assistent benutzen um formal richtigen Code zu schreiben/generieren
	\item \textbf{Fragestellung: Wie gewährleiste ich sichereren/gut getesteten Code?}
\end{itemize}


\section{Grundlagen}
\subsection{Was ist ein Proof Assisstant}
\url{https://www.youtube.com/watch?v=95VlaZTaWgc&t=2646s}


\subsubsection{Proof Verifier}
\subsubsection{Theorem Provers}

\subsection{Übersicht}
\url{https://en.wikipedia.org/wiki/Proof_assistant}
\begin{itemize}
	\item ACL2
	\item Isabelle
	\item Coq
\end{itemize}

\section{Coq}
\url{https://www.amazon.de/Certified-Programming-Dependent-Types-Introduction/dp/0262026651/ref=sr_1_fkmr0_1?__mk_de_DE=ÅMÅŽÕÑ&keywords=coq+proof+assistent&qid=1572974699&sr=8-1-fkmr0}
\begin{itemize}
	\item erster Release Mai 1989 (30 Jahre)
	\item funktionaler Programmierstil
	\item crossplatform
	\item open source
	\item wurde seit 1984 von INRIA ("`National Institute for Research in Computer Science and Automation"') supported
	\item Warum Coq?
\end{itemize}

\section{Programmatische Coq-Grundlagen}
\begin{itemize}
	\item Dependent type Sprache: So we established that we can prove things are true before we have a concrete value. To do this in an actual programming language, we need a way to encode these statements into the type system itself, which means our type system needs an upgrade. \url{https://medium.com/background-thread/the-future-of-programming-is-dependent-types-programming-word-of-the-day-fcd5f2634878}
	We're turning the above run-time assertion into compile-time type.
	\item \url{https://softwarefoundations.cis.upenn.edu/lf-current/Basics.html#lab18} \cite{Pierce01:COQ}
	\item Coq und Coqide - Zusammenspiel mit Screenshot => wird in Kapitel mit Beispielbeweis genauer drauf eingegangen
\end{itemize}
\subsection{Basisbegriffe}
\subsubsection{Typdefinition}
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Typedefinition,label=lst:typedefinition]
Inductive bool : Type :=
	| true
	| false.
	
Inductive day : Type :=
	| monday
	| tuesday
	| wednesday
	| thursday
	| friday
	| saturday
	| sunday.
	
Inductive nat : Type :=
	| O
	| S (n : nat).
\end{lstlisting}

Die Beispiele aus dem Codeblock \ref{lst:typedefinition} stellen drei Typedefinitionen in Coq dar. Ersteres ist ein klassischer Bool. Sowie dieser true oder false annehmen kann, repräsentiert der zweite Type day alle Wochentage. \\
Die letzte Definition wird verwendet um alle natürlichen Zahlen darzustellen. \textbf{S (n : nat)} stellt den Successor z.d. die Nachfolgefunktion dar. Somit kann durch diesen Typ jeder Zahlenwert der natürlichen Zahlen dargestellt werden. Eine 4 würde beispielsweise durch die vierte Nachfolgefunktion von 0 wie folgt dargestellt werden. \textbf{(S (S (S (S O)))) => 0 + 1 + 1 + 1 + 1 => 4}.\\
Des Weiteren ist es auch möglich Komposition durch das Schlüsselwort \textbf{Inductive} abzubilden.

\subsubsection{Funktionen}
In Coq gibt es mehrere Arten von Funktionstypen. Mit dem Keyword \textbf{Definition} können einfach Funktionen dargestellt werden. Oftmals wird allerdings Rekursion benötigt. Diese ist nur möglich, wenn die Deklaration mit \textbf{Fixpoint} oder ähnlichen Wörtern beschrieben ist. Anstelle von \textbf{Theorem} könnten Beispielsweise auch \textbf{Example, Lemma, Fact oder Remark} stehen. Diese Schlüsselwörter ermöglichen es in Coq mittels des Allquantors die Korrektheit einer Funktion für alle Elemente einer Menge zu beweisen.
In Codeblock \ref{lst:functions} ist für die unterschiedlichen Funktionstypen jeweils ein Beispiel dargestellt.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Funktionen,label=lst:functions]
Definition minustwo (n : nat) : nat :=
match n with
	| O => O
	| S O => O
	| S (S n') => n'
end.

Theorem plus_O_n' : forall n : nat,
0 + n = n.

Fixpoint plus (n : nat) (m : nat) : nat :=
match n with
	| O => m
	| S n' => S (plus n' m)
end.
\end{lstlisting}

Die erste Funktion \textbf{minustwo} zieht von einer eingegebenen natürlichen Zahl zwei ab. Allerdings ergibt \textbf{0 - 2, 1 - 2 => 0}. Dies ist durch die ersten zwei Fälle des \textbf{match}-Begriffs dargestellt.\\
Das \textbf{Theorem plus\_O\_n} liest sich wie folgt: "Für alle natürlichen Zahlen n gilt 0 + n = 0". Im folgenden Kapitel wird gezeigt, wie eine solche Funktion mathematisch bewiesen werden kann.

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq rekursive Funktion,label=lst:functions-executed]
(* Run function plus with 3 and 2. Result => 5 *)
Compute (plus 3 2).

(*  plus (S (S (S O))) (S (S O))
	==> S (plus (S (S O)) (S (S O)))
by the second clause of the match
	==> S (S (plus (S O) (S (S O))))
by the second clause of the match
	==> S (S (S (plus O (S (S O)))))
by the second clause of the match
	==> S (S (S (S (S O))))
by the first clause of the match
*)
\end{lstlisting}
Um ein tieferes Verständnis für die Rekursion in Coq zu bekommen, sind im Codeblock \ref{lst:functions-executed} die einzelnen Schritte in einem Kommentar-block (gekennzeichnet durch (* *)) abgebildet. Im 1. Schritt stellt Coq, wie bereits bei den Typdefinitionen der natürlichen Zahlen gezeigt, die Dezimalzahlen zwei und drei mittels der Successor-funktion dar. Anschließend beginnt die Rekursion. Solange \textbf{n > 0}, wird 1 mehr zum Endergebnis gezählt. Wenn \textbf{n = 0}, dann wird, wie in den letzten zwei Zeilen im Codeblock dargestellt, das plus durch \textbf{m} ersetzt. Somit ergibt \textbf{plus 3 2 => 5}.

\subsection{Beweise und Taktiken}
Úm zu prüfen, dass die definierten Funktionen mathematisch korrekt sind, stellt der Proof Assistent verschiedene Taktiken zur Verfügung. Diese werden zwischen den \textbf{Proof.} und \textbf{Qed.} Schlüsselworten angegeben.\\\
Eine grundlegende Beweismethode ist die Induktion, welche nur für die natürlichen Zahlen verwendet werden kann. Dabei wird zuerst geprüft, ob beim Einsetzen in die zu beweisende Funktion der kleinste Wert gültig ist. Anschließend soll die Aussage für \textbf{n + 1} bewiesen werden. Wenn beides zu einem gültigen Ergebnis führt, ist die Funktion mathematisch valide.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beispielbeweis,label=lst:sample-proof1]
Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
	intros n. 
	reflexivity. 
Qed.

Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
	intros n. 
	induction n as [| n' IHn'].
		- (* n = 0 *) reflexivity.
		- (* n = S n' *) simpl.
		  rewrite <- IHn'.
	reflexivity.
Qed.
\end{lstlisting}
Im Codeblock \ref{lst:sample-proof1} sind zwei Theoreme bewiesen. Ersteres kann durch zwei Taktiken geprüft werden. \textbf{Intros} in Verbindung mit allen verwendeten Variablen des Theorems, setzt diese in den Kontext. Dies ist vergleichbar mit: "Gegeben sei n, eine natürliche Zahl".\\
Ein anschließendes Anwenden von \textbf{reflexivity} sorgt dafür, dass das Programm überprüft, ob die linke und rechte Seite identisch sind. Dabei führt \textbf{reflexivity} auch noch ein \textbf{simpl} zur Vereinfachung (z.B.: 0 + n => 0) aus. \textbf{Reflexivity} muss somit immer am Ende eines Beweises stehen, sodass er abgeschlossen ist.\\
Die zweite Funktion wird mit Hilfe der Taktik \textbf{induction} gelöst. Diese teilt die Aussage in zwei Subgoals (z.d. Teilziele) auf. Anschließend gilt es, jedes einzelne Ziel zu prüfen. Diese werden in verschiedenen Ebenen mithilfe von \textbf{-, +, *} gekennzeichnet. Ein \textbf{-} wird bei der ersten Subgoal-Ebene verwendet. Für das Adressieren weiterer Subgoals von Subgoals werden \textbf{+} und \textbf{*} genutzt. Das Schlüsselwort \textbf{rewrite} wird in folgendem Unterkapitel erläutert. 
\subsection{Umfangreicherer Beweis}
\begin{itemize}
	\item Gegeben: Für die natürlichen Zahlen m, n und o gilt, dass n = m und m = o ist. Zu beweisen: n + m = m + o
	\item In den Kommentar-Blöcken, gekennzeichnet durch (* und *) wird das Ergebnis nach jedem einzelnen Schritt dargestellt.
	\item Wie bereits erwähnt, werden mit \textbf{Intros} die Variablen als gegeben markiert.
	Forall wird nun über der Linie angezeigt.
	\item Alles unter der Linie ist zu beweisen und drüber ist gegeben
	\item Die Zwei Hypothesen H1 und H2 in den Kontext setzen
	\item Anschließend ist nur noch n + m = m + o mit den gegebenen Sachen zu beweisen
	\item Es wird nun die Taktik \textbf{rewrite} oder nicht fachlich gesagt: Einsetzen genutzt.
	\item Es ist zu sehen, dass nach jedem Rewrite sich das End-Ziel verändert, bis schließlich m + m = m + m dasteht.
	\item Dies kann einfach mit reflexivity geprüft werden und der Beweis ist vollständig.
\end{itemize}
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beispielbeweis,label=lst:sample-proof2]
(* Initiating the theorem to proof. *)
Theorem plus_id_exercise : forall n m o : nat,
	n = m ->
	m = o ->
	n + m = m + o.
	
(* result: 
1 subgoal
______________________________________(1/1)
forall n m o : nat,
n = m -> m = o -> n + m = m + o*)

Proof.
(* move quantifiers into the context: *)
	intros n m o. 
	
(* result: 
1 subgoal
n, m, o : nat
______________________________________(1/1)
n = m -> m = o -> n + m = m + o*)

(* move hypothesises into the context: *)	
	intros H.
	intros H2.

(* result: 
1 subgoal
n, m, o : nat
H : n = m
H2 : m = o
______________________________________(1/1)
n + m = m + o*)

(* rewrite the goal using the hypothesises: *)
	rewrite -> H.

(* result: 
...
______________________________________(1/1)
m + m = m + o
*)
	rewrite <- H2.

(* result:
...
______________________________________(1/1)
m + m = m + m
*)
	reflexivity.
Qed.
\end{lstlisting}

\section{Coq und Programmcode}

Beim Zusammenspiel von Beweisen in Coq und Programmcode gibt es zwei verschiedene Richtungen. Einerseits können Theoreme bewiesen und dann in Programmiersprachen extrahiert werden. Andererseits ist es auch möglich, erst ein Programm zu entwickeln und anschließend dieses in Coq zu verifizieren. \\
Das dabei verwendete Prinzip lautet salopp gesagt:
\textbf{Es gibt eine Liste von Dingen, die eine Software tun soll. Hierfür wird Logik verwendet, um zu beweisen, dass diese Software auch genau diese Dinge tut.}
\\
In den folgenden Unterkapiteln sind beide Wege beschrieben. Dabei wird die Richtung Proof zu Programm anhand eines genauen Codebeispiels erläutert.

\subsection{Proof -> Programm}
\subsubsection{theoretisch}
\begin{itemize}
	\item \url{https://medium.com/@ahelwer/formal-verification-casually-explained-3fb4fef2e69a}
	\item Erstelle eine Spezifikation, die ein Programm beschreibt
	\item Schreibe die Spezifikation mathematisch in ein Proof Tool
	\item Wenn es Fehler enthält, sagt es dir der Verifier
	\item Code to Ocaml extractor ist nicht formal verifiziert. Wird aber viel verwendet, weil es einfach ist
\end{itemize}

\subsubsection{praktisch}
\begin{itemize}
	\item Programmcode in Coq bewiesen und dann in Ocaml extrahiert
	\item Ocaml ("`Categorical Abstract Machine + ML"') ist eine sowohl funktionale, als auch objektorientierte Programmiersprache.
	\item ML bedeutet Meta-Language. Dies ist für diese Arbeit weniger relevant, da Ocaml lediglich als Beispiel für Code-Extraction genutzt wird und der Fokus hauptsächlich auf dem Prinzip liegt.
\end{itemize}
\textbf{Funktionalitäten schreiben und mathematisch beweisen}
\begin{itemize}
	\item natprod beschreibt ein paar von 2 natürlichen Zahlen
	\item Check und Compute wird als Konsolen-Ausgabe genutzt
	\item fst gibt x zurück
	\item snd gibt y zurück
	\item Notation ist ein Alias um bestimmte Ausdrücke anders als normal zu schreiben
	\item swap\_pair vertauscht x und y
	\item surjective\_pairing und surjective\_pairing\_stuck beweist, dass das Erstellen von einem neuem Paar demselben entspricht, wenn man fst und snd von diesem Paar nimmt und ein neues Paar bildet.
	\item snd\_fst\_is\_swap und fst\_swap\_is\_snd prüft die swap\_pair Funktion auf Korrektheit.
	\item destruct bedeutet: The tactic that tells Coq to consider, separately, the cases where n = O and where n = S n' is called destruct. The destruct generates two subgoals, which we must then prove, separately, in order to get Coq to accept the theorem. The same as we used in induction. The difference of destruct and induction is, that induction is capable of checking n = 0, n+1 and than say, if this is correct -> the whole proof is correct. In this example we use destruct just to split the pair p into n and m again. Otherwise Coq can't simplify the statement.
\end{itemize}

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beispielbeweis,label=lst:practical-proof]
From LF Require Export Induction.

Inductive natprod : Type :=
	| pair (n1 n2 : nat).

Check (pair 3 5).

Definition fst (p : natprod) : nat :=
match p with
	| pair x y => x
end.

Definition snd (p : natprod) : nat :=
match p with
	| pair x y => y
end.

Compute (fst (pair 3 5)).
Compute (snd (pair 5 7)).

Notation "( x , y )" := (pair x y).

Compute (fst (3,5)).
Definition fst' (p : natprod) : nat :=
match p with
	| (x,y) => x
end.
Definition snd' (p : natprod) : nat :=
match p with
	| (x,y) => y
end.
Definition swap_pair (p : natprod) : natprod :=
match p with
	| (x,y) => (y,x)
end.

Theorem surjective_pairing' : forall (n m : nat),
(n,m) = (fst (n,m), snd (n,m)).
Proof.
	simpl.
	reflexivity. 
Qed.

Theorem surjective_pairing_stuck : forall (p : natprod),
p = (fst p, snd p).
Proof.
	intros p.
	destruct p as [n m].  
	simpl.
	reflexivity.
Qed.

Theorem snd_fst_is_swap : forall(p : natprod),
(snd p, fst p) = swap_pair p.
Proof.
	intros p.
	destruct p as [n m].
	simpl.
	reflexivity.
Qed.

Theorem fst_swap_is_snd : forall(p : natprod),
fst (swap_pair p) = snd p.
Proof.
	intros p.
	destruct p as [n m].
	simpl.
	reflexivity.
Qed.
\end{lstlisting}
Um anschließend die formal bewiesenen Funktionen in Programmen nutzen zu können, muss die Datei, in der die Beweise geschrieben wurden, in Coq compiliert werden. Dafür muss folgender Befehl in die Kommandozeile eingeben werden:
\textbf{coqc -Q . LF PaperPair.v}. \\
\textbf{Coqc} ist hierbei der Aufruf des Coq-Compilers. \textbf{-Q . LF} sorgt dafür, dass alle .v-Dateien aus dem Paket LF in andere Coq-Dateien importiert werden können. Ein Paket in Coq ist ähnlich zu anderen Programmiersprachen wie beispielsweise Java.
\\
Für den nächsten Schritt in der Extraktion wird eine Coq-Datei benötigt, welche definiert, wie und was in welcher Sprache extrahiert werden soll. Diese muss ebenfalls über die Kommandozeile, wie zuvor beschrieben, compiliert werden.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Code extrahieren,label=lst:practical-proof-extraction]
Require Extraction.
Extraction Language OCaml.
Require Import ExtrOcamlBasic.
Require Import ExtrOcamlString.
Require Import Arith Even Div2 EqNat Euclid.

Extract Inductive nat => int [ "0" "Pervasives.succ" ]
"(fun fO fS n -> if n=0 then fO () else fS (n-1))".

Extraction "paperimpl.ml" fst snd swap_pair.
\end{lstlisting}
Im Codeblock \ref{lst:practical-proof-extraction} ist zu sehen, dass verschiedene Dateien mit \textbf{Require} und \textbf{Require Import} importiert werden. \textbf{Extraction} und \textbf{ExtraOcamlBasic} sind beispielweise Standard-Features von Coq um Funktionen von Coq-Code in Ocaml-Code umzuwandeln.\\
Weiterhin wird in der Zeile \textbf{Extract Inductive nat => \dots} ein Ausdruck verwendet, sodass OCaml den Typ der natürlichen Zahlen aus Coq verwenden kann.
Damit schlussendlich eine ausführbare Datei entsteht, muss definiert werden, welche Funktionen in welche Datei extrahiert werden sollen.\\
\\
Der folgende Code \ref{lst:practical-generated-code} ist das Resultat, des zuvor gezeigten Coq-Codes. 
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code anpassen,label=lst:practical-generated-code]
type natprod =
| Pair of int * int

(** val fst : natprod -> int **)

let fst = function
| Pair (x, _) -> x

(** val snd : natprod -> int **)

let snd = function
| Pair (_, y) -> y

(** val swap_pair : natprod -> natprod **)

let swap_pair = function
| Pair (x, y) -> Pair (y, x)
\end{lstlisting}
Dadurch das der Coq-To-Ocaml-Extraktor nicht komplett formal verifiziert ist, kann es sein, dass der Code nicht 100\% korrekt ist. Um sicherzustellen, dass dies der Fall ist, wurden im Nachhinein ein paar Tests geschrieben, welche im Codebeispiel \ref{lst:practical-code-adjustment} dargestellt werden. Diese Tests beschreiben einfache Funktionsaufrufe wie zum Beispiel das Erhalten des ersten und zweiten Wertes eines Paares. Anschließend werden die selben Funktionen noch einmal aufgerufen - allerdings auf ein neues Paar, dass du die swap\_	pair Funktion entstanden ist. Zur Nachvollziehbarkeit werden dabei die jeweiligen Ergebnisse auf der Kommandozeile ausgegeben.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code anpassen,label=lst:practical-code-adjustment]
let pair = Pair(3, 4);;
let resultfst = fst pair;;
let resultsnd = snd pair;;

Printf.printf "Result fst: %d \n%!" resultfst;;
Printf.printf "Result snd: %d \n%!" resultsnd;;

let pair2 = swap_pair pair;;
let resultfst2 = fst pair2;;
let resultsnd2 = snd pair2;;

Printf.printf "Result fst: %d \n%!" resultfst2;;
Printf.printf "Result snd: %d \n%!" resultsnd2;;
\end{lstlisting}
Ocaml-Code muss genauso wie C-Code compiliert werden. Folgender Befehl ermöglicht es aus der \textbf{paperimpl.ml} und der \textbf{paperimpl.mli} Datei funktionierenden compilierten Code zu erhalten. Dieser wird unter dem Namen \textbf{paperimp} im selben Verzeichnis abgelegt.
\\
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code compilieren,label=lst:practical-code-compilation]
ocamlc -w -20 -w -26 -o paperimp paperimpl.mli paperimpl.ml
\end{lstlisting}

\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml code ausführen,label=lst:practical-code-execution]
lukas@luk-ubuntu@~/Documents/coq-test/lf: ./paperimp
Result fst: 3 
Result snd: 4 
Result fst: 4 
Result snd: 3 
\end{lstlisting}
In Codeblock \ref{lst:practical-code-execution} werden die Ausgaben der Tests dargestellt. Die ersten zwei Ergebnisse sind die Werte, welches mit den Werten \textbf{fst: 3} und \textbf{snd: 4} initiiert wurde. Die zweiten zwei Ausgaben stellen \textbf{fst} und \textbf{snd} des invertierten Paars dar.

\subsection{Programm -> Proof}
\begin{itemize}
	\item nutze Verified Software Toolchain (VST) der PrincetonUniversity um C Code mathematisch zu beweisen
	\item Schreibe ein C Program F.c
	\item Führe clightgen -normalize F.c aus. Dadurch entsteht eine Datei Coq-File F.v
	\item Schreibe eine formale Verifikation in einer Datei (z.B.: verif\_F.v). In dieser File müssen sowohl F.v als auch das VST Floya Programm-Verifikationssystem VST.floyd.proofauto importieren.\cite{Appel01:VST}
\end{itemize}

\section{Aktuelle Anwendung}
\subsection{Proofed Stack}
\begin{itemize}
	\item CompCert (C compiler)
	\item Princeton VST
	\item Certikos (verified Operating System with hypervisor and multi instances)
	\item \url{http://plv.csail.mit.edu/kami/}
	\item \url{https://www.zdnet.com/article/certikos-a-hacker-proof-os/}
	\item \url{https://github.com/PrincetonUniversity/VST}
	\item \url{https://vst.cs.princeton.edu}
	\item \url{https://news.yale.edu/2016/11/14/certikos-breakthrough-toward-hacker-resistant-operating-systems}
\end{itemize}
\subsection{CompCert for C}
\url{http://compcert.inria.fr}
\subsection{JSCert for ECMA 5}
\url{https://github.com/jscert/jscert}
\subsection{4-Farben Rätsel ist löstbar!}
\url{http://www.ams.org/notices/200811/tx081101382p.pdf}
\subsection{CertiCoq}
\url{https://www.cs.princeton.edu/~appel/papers/certicoq-coqpl.pdf}

\section{Anwendbarkeit in der Praxis}
\begin{itemize}
	\item Objektorientierung eher schwer, da direkte Umwandlung von funktionaler Sprache in eine funktionale Sprache einfacher ist. (Außerdem programmieren die Menschen, die das entwickeln eigentlich nicht wirklich objektorientiert)
	\item Sicherheitskritische Systeme
	\item Compilerbau
\end{itemize}


\section{Fazit}
\begin{itemize}
	\item Programmcodeverifikation nimmt vor allem in sicherheitskritischen Bereichen zu
	\item Programmcodeverifikation ist deutlich zeitintensiver (5mal)
	\item Mit dieser Verifikation kann 100\%tige Garantie für funktionierende Software gewährleistet werden
	\item Es hat großes Potential
	\item Wird sehr stark durch die Community weiterentwickelt
	\item Große Firmen nutzen es immer aktiver
\end{itemize}

\section{Glossar}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis.tex"
%%% End: 
