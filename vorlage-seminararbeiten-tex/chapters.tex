\section{Motivation}
{Wenn heutzutage die Spezifikation eines Projektes in englischer Sprache formuliert wird, ist diese Spezifikation von Anfang an mehrdeutig, behauptet Jeannette Wing, Coperate Vice President von Microsoft Research. Des Weiteren sagt sie, dass jede natürliche Sprache mehrdeutig ist. Hingegen in formalen Spezifikationen, wird mathematisch präzise erklärt, was genau ein Programm machen soll.}\cite{WING01:FV}
\\
\\
Diese Seminararbeit soll einen tieferen Einblick in den Themenbereich der Programmcodeverifikation schaffen. Dabei wird sowohl auf die Grundlagen als auch technisch-detaillierte Beispiele eingegangen. Als Programmiersprache wird hierfür der Proof-Assistent Coq verwendet.


\section{Relevanz formaler Verifikation}
Es existieren unzählige Beispiele für die Relevanz von formaler Verifikation. Jeder Computer besteht beispielsweise aus vielen elektronischen Hardwareteilen wie Prozessoren, Grafikkarte et cetera. Zur Benutzung wird eine Hardware Description Language (HDL) eingesetzt, welche sowohl die Struktur als auch das Verhalten der elektronischen Bauteile beschreibt. Falls eine Firma nun einen Computer mit einer fehlerhaften HDL-Software verkauft, kann dies gravierende Folgen nach sich ziehen.
Daher ist es wichtig, dass sowohl die Bauteile als auch das Zusammenspiel von Hardware und Software ausgiebig getestet werden.\\
\\
Heutzutage gehen die meisten Computer-Nutzer davon aus, dass ein Betriebssystem, ein Compiler oder andere Software zu 100\% korrekt funktionieren. Doch wie ist sichergestellt, dass das Speichern in einem Editor oder das Kompilieren von C Code auch in jedem Fall das gewünschte Ergebnis liefert? \\
Sehr wahrscheinlich wurden viele verschiedene Tests bereits vor der Veröffentlichung der jeweiligen Software durchgeführt. Die bekanntesten sind Unit-, Integration- und manuelle Tests. Dabei versucht man sowohl Standard- als auch Grenz- und Sonderfälle abzudecken, aber natürlich nicht jeden Einzelfall. Würde man einen kompletten Test durchführen, müsste beispielsweise für eine simple Funktion, die zwei Integer addiert, jeder beliebige Wert, den dieser annehmen könnte, getestet werden. Dies ist nicht in annehmbarer Laufzeit mit den oben genannten Testformen durchführbar.\\
Nichts desto trotz schränken viel Tests ein Fehlverhalten der jeweiligen Software ein. Dies ist für vielerlei Anwendungen bereits ausreichend. Allerdings vor allem in sicherheitskritischen und intensiv genutzten Systemen sollte diese zu 100\% korrekt funktionieren.
Um alle Fälle abzudecken, muss eine andere Syntax verwendet werden. Hier kommt die formale Verifikation zum Einsatz. 
Die dabei verwendete Sprache ist mathematisch aufgebaut und erlaubt es somit Konstrukte, wie beispielsweise \textbf{für alle natürlichen Zahlen gilt} niederzuschreiben.\\
Generell ist es möglich fast jeden Programmcode formal zu verifizieren. Der Aufwand, der dafür aufzubringen ist, unterscheidet sich von Fall zu Fall. Um den Code einer Sprache vollständig formal beweisen zu können, muss theoretisch auch der Compiler der Sprache formal bewiesen sein. Ansonsten wäre zwar der Programmcode formal verifiziert, allerdings kann nicht garantiert werden, dass der Compiler dennoch keine Fehler beim Übersetzen macht. Des Weiteren ist noch zu erwähnen, dass der Compiler nicht die niedrigste Software-Ebene repräsentiert. In den Schichten darunter sind beispielsweise noch Hardwarebeschreibungssprachen. Sobald dort ein gravierender Bug enthalten ist, kann der high-level Programmcode formal bewiesen sein und trotzdem fehlerhaft laufen.
\\
Zum Zeitpunkt dieser Arbeit existieren circa 17 verschiedene Tools für formale Verifikation. Dabei sind \textbf{Coq}, \textbf{Isabelle} und \textbf{ACL2} die bekanntesten.\cite{WIEDIJK01:FP}
In dieser Arbeit wird ausschließlich auf Coq eingegangen.

\section{Einführung in Coq}
\subsection{Begriffe}
Ein \textbf{Theorem Prover} ist ein Programm.
In diesem werden Aussagen definiert, die das Tool zu beweisen versucht, falls es möglich ist.\\
\\
Ein \textbf{Proof Assistent}, welcher auch interaktiver Theorem Prover genannt wird, ist ein Softwaretool, das hilft formale Beweise durchzuführen. Dabei wird ein interaktiver Editor verwendet, mit dem es möglich ist, programmatisch Schritt für Schritt Beweise zu schreiben. Die Software interagiert dabei mit dem Bediener.
 

\subsection{Das Projekt Coq}
Der Proof Assistent Coq wurde erstmals im Mai 1989 veröffentlicht. Das National Institute for Research in Computer Science and Automation (INRIA) hat dessen Entwicklung bereits seit 1984 unterstützt.\cite{COQ02:FV} Der Name leitet sich vom französischen Wort Coq (zu Deutsch Hahn) ab. Traditionell werden Entwicklungswerkzeuge in Frankreich nach Tieren benannt. Außerdem erinnert der Name an den französischen Mathematiker und Informatiker Thierry Coquand. \\
Bestandteile des Coq-Projekts sind die funktionale Programmiersprache Coq selbst und eine Entwicklungsumgebung namens CoqIde. Beides ist zum heutigen Zeitpunkt plattform-unabhängig und open-source erhältlich unter \url{https://github.com/coq/coq}. Die dort aktuell veröffentlichte Version ist 8.10.2.\cite{COQ01:FV}\\
Coq ist zum größtenteils in Ocaml geschrieben. Das grundlegende Feature der Programmiersprache ist das Prüfen auf formale Richtigkeit von Beweisen. Dabei wird der Entwickler durch die eingebaute Entwicklungsumgebung CoqIde interaktiv während des Schreibens eines Beweises unterstützt. Eine weitere Funktionalität ist die Code Extraktion. Coq bietet diese für Ocaml, Haskel oder mit Hilfe von externen Bibliotheken auch für C an. Dies wird im Kapitel \ref{s:coq-and-code} detailliert anhand eines Beispiels aufgegriffen. Dabei werden Funktionen formal verifiziert und anschließend in ausführbaren Ocaml Code extrahiert.\\
Im Großen und Ganzen ist es eine aktuell sehr weit verbreite Sprache für formale Verifikation. Dabei wird sowohl Programmcode verifiziert als auch mathematische Theoreme bewiesen, welche auch teilweise unabhängig zum Fachbereich Informatik sind. Die Anwendungsbereiche sind im Kapitel \ref{s:current-usage} genauer erläutert.

\subsection{Bewertung von Coq mittels Open Hub}
Der Online-Dienst \textbf{Open Hub}, ehemals \textbf{Ohloh} genannt, katalogisiert open-source Softwareprojekte. Für jedes Projekt werden Daten wie Name, Beschreibung und Sourcecode erfasst. Basierend auf diesen Daten erstellt Open Hub eine Statistik, die es ermöglicht Codeanalyse, Projektmitarbeiter, Aktivitäten und eine Übersicht zu erhalten. Dabei fließen auch Daten weiterer open-source Projekte ein, um aussagekräftige Statistiken und Aussagen treffen zu können.\\
\\
{In der Auswertung steht beispielsweise, dass Coq aus über 30000 Beiträgen von 246 Entwicklern entstanden ist. Weiterhin wird der Codestand mit qualitativ hochwertig bewertet. Trotz der großen Menge an Contributern, scheint die Anzahl an Beiträgen in diesem Jahr im Vergleich zum Vorjahr abzunehmen. Dies könnte einerseits bedeuten, dass das Interesse schwindet, andererseits ist es auch möglich, dass der Code weniger Bugfixes und Änderungen benötigt.}\cite{OH01:FV}\\

\section{Programmatische Coq-Grundlagen}
In diesem Kapitel werden die Grundlagen der Programmiersprache Coq erläutert. Es wird zuerst auf das spezielle Type-System eingegangen. Das dabei verwendete Konzept stellt die Basis für programmatische formale Verifikation dar. Weiterhin werden die darauf aufbauenden Coq-Features und das Zusammenspiel von Coq und der interaktiven CoqIde erklärt.\\

\subsection{Dependent Type Language}
Java, C\# und PHP verwenden Objekte als universellen Datentyp. C und Go nutzen hingegen Strukturen. Das Typ-System von Coq basiert weder auf Objekten, noch auf Strukturen - es ist eine dependent Type (zu Deutsch typ-abhängige) Sprache.\\
Angenommen es gäbe eine Funktion, die irgendetwas mit einem User-Objekt/einer User-Struktur macht. In den häufig verwendeten Sprachen, wie beispielsweise Java, sollten die ersten Zeilen einen Check beinhalten, ob das User-Objekt null ist. (siehe Codeblock \ref{lst:java-function}).
\begin{lstlisting}[language=coq,firstnumber=1,caption=Java Funktion für den initialen Check auf null des User Objektes,label=lst:java-function]
public void doSomething(User user) {
	if(user == null) {
		throw new Exception("Recieved empty user!");
	}
...
}
\end{lstlisting}
Dadurch ist gewährleistet, dass, wenn es zu einem Fehler während der Laufzeit kommen sollte, dieser kontrolliert abgefangen wird. Allerdings bedeutet dies auch, dass die Funktion den Status eines User-Objekts, welches null ist, als gültiges Objekt entgegennimmt.\\
Praktischer wären Funktionen, welche bereits zum Compilierungs-Zeitpunkt prüfen, ob das übergebene Objekt korrekt ist.
Dies ist mit Hilfe von typ-abhängigen Sprachen umsetzbar. In Coq heißt diese \textbf{Gallina}. Dabei muss zuerst definiert werden, was einen \textbf{korrekten User} charakterisiert. Beispielsweise könnte es bedeuten, dass er ungleich null oder einer bestimmte Rolle zugeordnet ist. Dadurch könnte die folgende Funktion in Form von Pseudocode geschrieben werden.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Pseudocode Check auf null des User Objektes,label=lst:pseudocode-checked-function]
setRole: (user: User, role: String) -> userWithRole: User,
			where userWithRole.role == role;
\end{lstlisting}
Es muss noch eine weitere grundlegende Voraussetzung erfüllt sein, damit diese Funktion bereits beim Kompilieren auf Korrektheit geprüft werden kann. Ein Typ repräsentiert normalerweise unterschiedliche Ausprägungen. Allerdings wird für typ-abhängige Sprachen für jede Ausprägung ein eigener Typ benötigt.\\
Unter der Annahme, dass es beispielsweise insgesamt drei verschiedene Rollen (UserWithAdminRole, UserWithSupportRole, UserWithUserRole) gibt, können einzelne Typen für jede Rolle erstellt werden.
Jetzt ist es möglich, dass bereits der Compiler sicherstellen kann, dass die Funktion aus Codeblock \ref{lst:pseudocode-checked-function} korrekt abläuft. Zur Erklärung hilft folgendes Beispiel:
\begin{lstlisting}[language=coq,firstnumber=1,caption=Pseudocode Check auf null des User Objektes,label=lst:pseudocode-checked-function-usage]
result: UserWithAdminRole = setRole (user, adminRole);
\end{lstlisting}
Jeder der oben genannten Typen stellt genau einen User mit einer bestimmten Rolle mit einem bestimmten Wert dar. Dies bedeutet typ-abhängig.\cite{MARTIN01:FV}
Zusammenfassend gesagt, ist es durch typ-abhängige Sprachen möglich zu prüfen, ob etwas wahr ist, bevor ein konkretes Objekt beziehungsweise eine Instanz mit Werten erstellt wurde. Die durchgeführten Checks, die normalerweise bei der Laufzeit durchlaufen werden, sind dadurch bereits zur Compilezeit des Programms geprüft.\\
\\
Diese Art von Typ-System benötigt einerseits für jeden Wert einen eigenen Typ, andererseits entstehen dadurch viele neue Optionen. Die viele Arbeit zur Erstellung eines Typs pro Wert, übernimmt der Compiler.\\
Der größte Vorteil ist die Vermeidung von Bugs. Zugriffe auf nicht existente Array Indizes, Nullpointer-Exceptions oder nicht endlicher Code sind faktisch keine Probleme in typ-abhängigen Sprachen, falls die korrekten Beweise durchgeführt wurden.\\
\\
Generell ist es möglich fast alles mit dependent Types darzustellen. Beispielsweise eine Login-Funktion, die keine Leerstrings erlaubt, oder eine Funktion, die natürliche Zahlen dividiert ohne eine Null zu erlauben, ist dadurch problemlos umsetzbar.
\subsection{Basisbegriffe}
\subsubsection{Typdefinition}
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Typedefinition,label=lst:typedefinition]
Inductive bool : Type :=
	| true
	| false.
	
Inductive day : Type :=
	| monday
	| tuesday
	| wednesday
	| thursday
	| friday
	| saturday
	| sunday.
	
Inductive nat : Type :=
	| O
	| S (n : nat).
\end{lstlisting}

Die Beispiele aus dem Codeblock \ref{lst:typedefinition} stellen drei Typedefinitionen in Coq dar. Ersteres ist ein klassischer Bool, der true oder false annehmen kann. Der zweite Typ day repräsentiert alle Wochentage. \\
Die letzte Definition wird verwendet, um alle natürlichen Zahlen darzustellen. \textbf{S (n : nat)} stellt den Successor, zu Deutsch die Nachfolgefunktion, dar. Dadurch kann jeder Zahlenwert der natürlichen Zahlen dargestellt werden. Eine 4 würde beispielsweise durch die vierte Nachfolgefunktion von 0 wie folgt dargestellt werden. \textbf{(S (S (S (S O)))) => 0 + 1 + 1 + 1 + 1 => 4}.\\
Durch das Schlüsselwort \textbf{Inductive} ist es möglich Komposition abzubilden.

\subsubsection{Funktionen}
In Coq gibt es mehrere Arten von Funktionstypen. Mit dem Keyword \textbf{Definition} können einfache Funktionen dargestellt werden.
Ein \textbf{Theorem} ermöglichen es in Coq mittels des Allquantors die Korrektheit einer Funktion für alle Elemente einer Menge zu beweisen. 
Anstelle dessen, können auch \textbf{Example, Lemma, Fact oder Remark} stehen.
Rekursionen hingegen werden sind mit \textbf{Fixpoint} oder ähnlichen Wörtern beschrieben.
Im Codeblock \ref{lst:functions} ist für die unterschiedlichen Funktionstypen jeweils ein Beispiel dargestellt.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Funktionen,label=lst:functions]
Definition pred (n : nat) : nat :=
match n with
| O => O
| S n' => n'
end.

Definition minustwo (n : nat) : nat :=
match n with
	| O => O
	| S O => O
	| S (S n') => n'
end.

Theorem plus_O_n' : forall n : nat,
0 + n = n.

Fixpoint plus (n : nat) (m : nat) : nat :=
match n with
	| O => m
	| S n' => S (plus n' m)
end.
\end{lstlisting}
Die erste Funktion \textbf{pred} gibt den Vorgänger (Predecessor) einer natürlichen Zahl zurück.
Die zweite Funktion \textbf{minustwo} zieht von einer eingegebenen natürlichen Zahl zwei ab. Allerdings ergibt \textbf{0 - 2} und \textbf{1 - 2 => 0}. Dies ist durch die ersten zwei Fälle des \textbf{match}-Begriffs dargestellt.\\
Das \textbf{Theorem plus\_O\_n} liest sich wie folgt: "`Für alle natürlichen Zahlen n gilt 0 + n = n"'. Im folgenden Kapitel wird gezeigt, wie eine solche Funktion mathematisch bewiesen werden kann.\\
\textbf{Fixpoint plus} ist eine Addition zweier natürlicher Zahlen. Hierfür wird Rekursion verwendet.

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq rekursive Funktion,label=lst:functions-executed]
(* Run function plus with 3 and 2. Result => 5 *)
Compute (plus 3 2).

(*  plus (S (S (S O))) (S (S O))
	==> S (plus (S (S O)) (S (S O)))
by the second clause of the match
	==> S (S (plus (S O) (S (S O))))
by the second clause of the match
	==> S (S (S (plus O (S (S O)))))
by the second clause of the match
	==> S (S (S (S (S O))))
by the first clause of the match
*)
\end{lstlisting}
Zum besseren Verständnis für den Ablauf der Rekursion in Coq, sind im Codeblock \ref{lst:functions-executed} die einzelnen Schritte in einem Kommentar-block (gekennzeichnet durch (* *)) abgebildet. In Zeile stellt Coq, wie bereits bei den Typdefinitionen der natürlichen Zahlen gezeigt, die Zahlen zwei und drei mittels der Nachfolger-Funktion dar. Anschließend beginnt die Rekursion. Solange \textbf{n > 0}, wird 1 mehr zum Endergebnis gezählt. Wenn \textbf{n = 0}, dann wird, wie in den letzten zwei Zeilen im Codeblock dargestellt, das plus durch \textbf{m} ersetzt. Somit ergibt \textbf{plus 3 2 => 5}.

\subsection{Beweise und Taktiken}
Úm zu prüfen, dass die definierten Funktionen mathematisch korrekt sind, stellt der Proof Assistent verschiedene Taktiken zur Verfügung. Diese werden zwischen den \textbf{Proof.} und \textbf{Qed.} Schlüsselworten angegeben.\\\
Eine grundlegende Beweismethode ist die Induktion, welche nur für die natürlichen Zahlen verwendet werden kann. Dabei wird zuerst geprüft, ob beim Einsetzen in die zu beweisende Funktion der kleinste Wert gültig ist. Anschließend soll die Aussage für \textbf{n + 1} bewiesen werden. Wenn beides zu einem gültigen Ergebnis führt, ist die Funktion mathematisch valide.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beispielbeweis,label=lst:sample-proof1]
Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
	intros n. 
	reflexivity. 
Qed.

Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
	intros n. 
	induction n as [| n' IHn'].
		- (* n = 0 *) reflexivity.
		- (* n = S n' *) simpl.
		  rewrite <- IHn'.
	reflexivity.
Qed.
\end{lstlisting}
Im Codeblock \ref{lst:sample-proof1} sind zwei Theoreme bewiesen. \textbf{Theorem plus\_1\_l} prüft ob \textbf{1 + n} der Nachfolger-Funktion von \textbf{n} entspricht.
Für den Beweise werden zwei Taktiken genutzt. \textbf{Intros} in Verbindung mit allen verwendeten Variablen des Theorems, setzt diese in den Kontext. Dies ist vergleichbar mit: "`Gegeben sei n, eine natürliche Zahl"'.\\
Ein anschließendes Anwenden von \textbf{reflexivity} sorgt dafür, dass das Programm überprüft, ob die linke und rechte Seite identisch sind. Dabei führt \textbf{reflexivity} auch ein \textbf{simpl} zur Vereinfachung (z.B.: 0 + n => n) aus. \textbf{Reflexivity} muss somit immer am Ende eines Beweises stehen, sodass er abgeschlossen werden kann.\\
Die zweite Funktion \textbf{plus\_n\_O} validiert das \textbf{n = n + 0} gilt und wird mit Hilfe der Taktik \textbf{induction} gelöst. Diese teilt die Aussage in zwei Subgoals (zu Deutsch Teilziele) auf, passend zu Induktion. Dabei wird geprüft, dass sowohl \textbf{n = 0} (Zeile 11) und \textbf{n + 1} (Zeile 12-13) gilt.
Anschließend muss jedes einzelne Ziel überprüft werden. Dies verschiedenen Ebenen von Subgoals sind mit Hilfe von \textbf{-, +, *} gekennzeichnet. Der \textbf{*}-Operator ist dabei nicht mit der vorher beschriebenen Kommentar-Notation \textbf{(* *)} zu verwechseln. Ein \textbf{-} wird bei der ersten Teilziel-Ebene verwendet. Für das Adressieren weiterer Subgoals von Subgoals werden \textbf{+} und \textbf{*} genutzt. Das Schlüsselwort \textbf{rewrite} wird in folgendem Unterkapitel erläutert.

\subsection{Anwendung von Coq}
Dieses Kapitel beinhaltet einen Beispielbeweis und geht somit auf den praktischen Einsatz von Coq ein. Dabei wird die interaktive Entwicklungsumgebung CoqIde verwendet. Das bedeutet, dass der Nutzer während des Beweisvorgangs Informationen vom Programm erhält. Dies können sowohl Hinweise als auch Fehlermeldungen sein. Um sich die CoqIde genauer vorstellen zu können, wird folgende Illustration \ref{fig:coqide-sample} verwendet.\\

\begin{minipage}{\textwidth}
	\centering
	\captionsetup{type=figure}
	\includegraphics[width=1\textwidth]{\figdir/Coqide-sample.png}
	\caption{Coqide}
	\label{fig:coqide-sample}
\end{minipage}
\\
\\
Die CoqIde bietet viele spezielle Features für formale Verifikation. Beispielsweise ist es möglich mit den Pfeilen in der Navigationsleiste die einzelnen Kommandos aus der linken Textbox auszuführen. Je nach Pfeil springt man einen Schritt vorwärts, bis zum Mauszeiger vorwärts oder auch rückwärts.\\
\\
Die Entwicklungsumgebung besteht grundsätzlich aus drei Fenster. Dabei wird eines für den Programmcode genutzt. Die anderen beiden Fenster auf der rechten Seite dienen ausschließlich der Informationsausgabe.\\
Im Screenshot ist ein Beweis zu sehen. Dabei wird überprüft, wenn die natürlichen Zahlen \textbf{n, m, o} und die Beziehungen \textbf{n = m} und \textbf{m = o} gegeben sind, dass \textbf{n + m = m + o} gilt.\\
Zunächst fällt auf, dass der Coq-Code teilweise grün markiert ist. Dies symbolisiert den bereits erfolgreich ausgeführten Teil. Das Ausgabefenster rechts oben zeigt, hierfür die passende Ausgabe. Dabei werden über dem Trennstrich die gegebenen Variablen und Hypothesen angezeigt. Zusätzlich ist noch die Anzahl an Zielen abgebildet. Den darunter stehenden Ausdruck gilt es zu beweisen.\\
Das dritte Fenster rechts unten dient zur Meldung von Hinweisen, Fehlern und Konsolenausgaben, wie beispielsweise von einer Suche.\\
\\
Im Anschluss  Codeblock \ref{lst:sample-proof2} folgt die detaillierte Ausgabe der CoqIde nach jedem Schritt des in Abbildung \ref{fig:coqide-sample} gezeigten Beispiels.
Diese ist durch die Kommentarblöcke gekennzeichnet, welche durch \textbf{(* result:} eingeleitet und durch \textbf{*)} beendet werden.
Wie bereits zuvor erwähnt, gilt es \textbf{n + m = m + o} zu beweisen. Die gegebenen Hypothesen sind \textbf{n = m} und \textbf{m = o}. Nachdem das Theorem durch die CoqIde eingelesen wurde (grün markiert in Abbildung \ref{fig:coqide-sample}), ergibt sich die Ausgabe von Zeile 7 - 11. Darin ist das fast unveränderte Theorem abgebildet. Wie bereits im vorherigen Kapitel erklärt, gilt es alles unter dem Trennstrich zu beweisen.\\
Als nächstes wird der Beweis durch das Schlüsselwort \textbf{Proof} in Zeile 13 gestartet. Mit Hilfe von \textbf{intros} in Zeile 15 sind die drei Variablen n m o in den Kontext gesetzt. Das Resultat dieser Operation ist in Zeile 19 zu erkennen. Die Variablen werden nun als gegeben angesehen. Dasselbe Kommando ermöglicht es die zwei Hypothesen \textbf{H} und \textbf{H2} aufzustellen. Somit ergibt sich die Ausgabe in den Zeilen 27 bis 33. Die gegebenen Variablen und Hypothesen sind oberhalb der Linie aufgelistet und darunter ist das einzige zu beweisende Ziel \textbf{n + m = m + o} zu sehen. Die in den zwei Zeilen 36 und 43 verwendete Taktik \textbf{rewrite} nutzt \textbf{H} und \textbf{H2}.
\textbf{Rewrite} bedeutet vereinfacht ausgedrückt, dass je nach Richtung des Pfeils die eine oder andere Seite eingesetzt wird. In Zeile 41 ist das Ergebnis nach dem Einsetzen von der Hypothese \textbf{H} dargestellt, wobei alle \textbf{n}'s durch \textbf{m}'s ersetzt wurden. Selbiges Resultat entsteht nach der Verwendung von \textbf{H2}. Allerdings werden dabei alle \textbf{o}'s durch \textbf{m}'s ersetzt. In beiden Ausgaben sind nur \dots zu sehen, da der gegebene Teil unverändert bleibt.
Abschließend kann das Ziel mit \textbf{reflexivity} bewiesen werden, da \textbf{m + m} dasselbe ist, wie \textbf{m + m}.

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beispielbeweis,label=lst:sample-proof2]
(* Initiating the theorem to proof. *)
Theorem plus_id_exercise : forall n m o : nat,
	n = m ->
	m = o ->
	n + m = m + o.
	
(* result: 
1 subgoal
______________________________________(1/1)
forall n m o : nat,
n = m -> m = o -> n + m = m + o*)

Proof.
(* move quantifiers into the context: *)
	intros n m o. 
	
(* result: 
1 subgoal
n, m, o : nat
______________________________________(1/1)
n = m -> m = o -> n + m = m + o*)

(* move hypothesises into the context: *)	
	intros H.
	intros H2.

(* result: 
1 subgoal
n, m, o : nat
H : n = m
H2 : m = o
______________________________________(1/1)
n + m = m + o*)

(* rewrite the goal using the hypothesises: *)
	rewrite -> H.

(* result: 
...
______________________________________(1/1)
m + m = m + o
*)
	rewrite <- H2.

(* result:
...
______________________________________(1/1)
m + m = m + m
*)
	reflexivity.
Qed.
\end{lstlisting}

\section{Coq und Programmcode}
\label{s:coq-and-code}
Beweise in Coq können in zwei verschiedenen Richtungen in Verbindung mit Programmcode verwendet werden. Einerseits ist es möglich, Theoreme zuerst in Coq zu beweisen und anschließend in Programmiersprachen zu extrahieren. Andererseits kann auch erst ein Programm entwickelt werden, um es anschließend in Coq zu verifizieren. Das dabei verwendete Prinzip lautet vereinfacht gesagt:
\textbf{Es gibt eine Liste von Dingen, die eine Software tun soll. Hierfür wird Logik verwendet, um zu beweisen, dass diese Software auch genau diese Dinge tut.}
\\
In den folgenden Unterkapiteln sind beide Wege beschrieben. Dabei wird die Richtung Proof in Coq zu Programm anhand eines genauen Codebeispiels erläutert.


\subsection{Proof -> Programm}
\subsubsection{Theorie}
{Wie bereits erwähnt, ist der erste Schritt die Erstellung einer Spezifikation, welche die Software beschreibt. Anschließend muss diese in mathematischer Form in Coq geschrieben und bewiesen werden. Fehlerhafte Beweise lässt der Proof-Assistent nicht zu.
Dadurch sollten alle Fälle, welche in der realen Welt auftreten, mit diesem beschriebenen Modell abdeckt sein.\\
Schlussendlich müssen die bewiesenen Anforderungen der Spezifikation von Coq-Code in Programmcode konvertiert werden. Dieser Prozess wird in folgendem Kapitel genauer erklärt.}\cite{HELWER01:FV}

\subsubsection{Praxis}
In diesem Kapitel wird erklärt, wie Funktionen formal mit Coq bewiesen werden und anschließend in Ocaml extrahiert und ausgeführt werden. Ocaml ("`Categorical Abstract Machine + ML"') ist eine sowohl funktionale als auch objektorientierte Programmiersprache. ML bedeutet Meta-Language. In dieser Arbeit dient Ocaml lediglich als Beispiel für die Code-Extraktion aus Coq. Allerdings ist der Coq-Code zu Ocaml Extraktor nicht formal verifiziert. Die Korrektheit wird trotzdem angenommen, da Coq größtenteils in Ocaml geschrieben ist.\\
Das verwendete Beispiel \ref{lst:practical-functions} stellt einen Datentyp Paar von natürlichen Zahlen dar. Hierfür sollen verschiedene Funktionalitäten implementiert werden, die die Ausgabe des ersten und zweiten Wertes und das Vertauschen ermöglicht.
Zunächst muss eine \textbf{.v}-Datei erstellt werden, in welche der Coq-Code geschrieben wird. Anschließend sind sowohl die Funktionen als auch die dazugehörigen Beweise, die die Eigenschaften der einzelnen Funktionen prüfen, dargestellt.

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Funktionen für Paare aus natürlichen Zahlen (PaperPair.v),label=lst:practical-functions]
From LF Require Export Induction.

Inductive natprod : Type :=
	| pair (n1 n2 : nat).

Definition fst (p : natprod) : nat :=
match p with
	| pair x y => x
end.

Definition snd (p : natprod) : nat :=
match p with
	| pair x y => y
end.

Compute (fst (pair 3 5)).
Compute (snd (pair 5 7)).

Notation "( x , y )" := (pair x y).

Compute (fst (3,5)).

Definition swap_pair (p : natprod) : natprod :=
match p with
	| (x,y) => (y,x)
end.
\end{lstlisting}
Zu Beginn wird der \textbf{induktive Typ natprod} definiert, welcher ein Paar natürlicher Zahlen repräsentiert. Die Funktionen \textbf{fst} und \textbf{snd} geben jeweils x oder y eines Paares zurück. Im darauffolgenden Teil des Codebeispiels wird mehrmals das Schlüsselwort \textbf{Compute} verwendet. Mit Hilfe dieser Funktion können stichprobenartig einzelne Werte in die Definitionen eingesetzt werden. Dies dient zu Test- und Debugging-Zwecken. Beispielsweise Compute aus der Zeile 16 zeigt den Wert 3 in der CoqIde Ausgabe.\\
Weiterhin ist eine Notation für die Definition von Paaren in Zeile 19 dargestellt. Diese dient ausschließlich dafür, dass anstelle von 
\textbf{(pair x y)} auch \textbf{(x , y)} verwendet werden darf, wie in Zeile 21 zu sehen ist. Ohne eine solche Notation müsste eine komplett neue Funktion \textbf{fst'} für die Syntax von \textbf{(x , y)} geschrieben werden. Notationen sind prinzipiell Aliase und tragen zur Kürzung des Programmieraufwands bei.\\
Zuletzt wird die \textbf{swap\_pair} Funktion definiert, die den x- und y-Wert eines Paares vertauscht zurückgibt.\\
\\
Anschließend werden die Eigenschaften in Codebeispiel \ref{lst:practical-proof} bewiesen, welche diese Funktionen erfüllen sollen.
Zuerst wird mit Hilfe der Theoreme \textbf{surjective\_pairing} und \textbf{surjective\_pairing\_stuck} bewiesen, dass das Erstellen von einem neuen Paar demselben entspricht, wenn man fst und snd von diesem Paar nimmt und daraus ein neues Paar bildet. Die zwei Funktionen unterscheiden sich lediglich in der Verwendung der Syntax von Paaren. Beim Beweis von \textbf{surjective\_pairing\_stuck} wird außerdem die \textbf{destruct} Taktik benötigt.\\
Diese teilt normalerweise das Hauptziel des Beweises in die einzelnen Subgoals \textbf{n = 0} und \textbf{n = S n'} auf. Sobald beide Ziele bewiesen wurden, akzeptiert Coq dieses Theorem. Hierbei ist der Unterschied der Induktion, dass dabei \textbf{n = 0} und \textbf{n + 1} gecheckt wird und anschließend die Schlussfolgerung auf Korrektheit möglich ist.\\
Im Beispiel wird \textbf{destruct} jedoch nur zur Aufteilung von dem Paar \textbf{p} in die natürlichen Zahlen n und m verwendet.
Ab dieser Zeile entspricht der Beweis exakt dem Ersten, welcher von Anfang an natürliche Zahlen verwendet.

\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Beweise für Paar Funktionen (PaperPair.v),label=lst:practical-proof]
Theorem surjective_pairing' : forall (n m : nat),
(n,m) = (fst (n,m), snd (n,m)).
Proof.
	simpl.
	reflexivity. 
Qed.

Theorem surjective_pairing_stuck : forall (p : natprod),
p = (fst p, snd p).
Proof.
	intros p.
	destruct p as [n m].  
	simpl.
	reflexivity.
Qed.

Theorem snd_fst_is_swap : forall(p : natprod),
(snd p, fst p) = swap_pair p.
Proof.
	intros p.
	destruct p as [n m].
	simpl.
	reflexivity.
Qed.

Theorem fst_swap_is_snd : forall(p : natprod),
fst (swap_pair p) = snd p.
Proof.
	intros p.
	destruct p as [n m].
	simpl.
	reflexivity.
Qed.
\end{lstlisting}

Die letzten zwei Theoreme prüfen bestimmte Eigenschaften der \textbf{swap\_pair} Funktion. Zuerst wird mit \textbf{snd\_fst\_is\_swap} bewiesen, dass das zweite Element eines Paares in Verbindung mit dem ersten das Ergebnis der Definition \textbf{swap\_pair} ist. Der letzte Beweis \textbf{fst\_swap\_is\_snd} stellt sicher, dass für jeden \textbf{natprod} das erste Element eines Paares nach einem Aufruf von \textbf{swap\_pair} dem ursprünglich zweiten Wert des Paares entspricht.\\
Beide Theoreme werden identisch zu \textbf{surjective\_pairing\_stuck} bewiesen. Dabei wird der \textbf{natprod}-Typ ebenfalls mit Hilfe von \textbf{destruct} in zwei natürliche Zahlen aufgeteilt.\\
\\
Um anschließend die formal bewiesenen Funktionen in Programmen nutzen zu können, muss die Datei, in der die Beweise geschrieben wurden, in Coq compiliert werden. Dafür muss folgender Befehl in die Kommandozeile eingeben werden:\\
\textbf{coqc -Q . LF PaperPair.v} \\
\textbf{Coqc} ist hierbei der Aufruf des Coq-Compilers. \textbf{-Q . LF} sorgt dafür, dass alle .v-Dateien aus dem Paket LF in andere Coq-Dateien importiert werden können. Ein Paket in Coq ist ähnlich zu anderen Programmiersprachen wie beispielsweise Java. \textbf{PaperPair.v} repräsentiert die Datei mit den Inhalten von den zuvor gezeigten Codeblöcken \ref{lst:practical-functions} und \ref{lst:practical-proof}.
\\
Für den nächsten Schritt in der Extraktion muss eine weitere Coq-Datei mit dem Code aus aus Codeblock \ref{lst:practical-proof-extraction} erstellt werden, welche definiert, wie und was in welcher Sprache extrahiert werden soll.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Coq Code extrahieren (PaperPairExtraction.v),label=lst:practical-proof-extraction]
Require Extraction.
Extraction Language OCaml.
Require Import ExtrOcamlBasic.
Require Import ExtrOcamlString.
Require Import Arith Even Div2 EqNat Euclid.

Extract Inductive nat => int [ "0" "Pervasives.succ" ]
"(fun fO fS n -> if n=0 then fO () else fS (n-1))".

Extraction "paperimpl.ml" fst snd swap_pair.
\end{lstlisting}
Darin ist zu sehen, dass verschiedene Dateien mit \textbf{Require} und \textbf{Require Import} importiert werden. \textbf{Extraction} und \textbf{ExtraOcamlBasic} sind beispielsweise Standard-Features von Coq, um Funktionen von Coq-Code in Ocaml-Code umzuwandeln.\\
Weiterhin wird in der Zeile 7 und 8 \textbf{Extract Inductive nat => \dots} ein Ausdruck verwendet, sodass Ocaml den Typ der natürlichen Zahlen aus Coq verwenden kann. 
Damit schlussendlich eine ausführbare Datei entsteht, muss definiert werden, welche Funktionen in welche Datei extrahiert werden sollen, was mit Zeile 10 geschieht.\\
Anschließend muss diese Datei ebenfalls über die Kommandozeile, wie zuvor beschrieben, compiliert werden.
\\
Der folgende Ocaml-Code \ref{lst:practical-generated-code} und \ref{lst:practical-generated-code-header} ist das Resultat des zuvor gezeigten Coq-Codes. Dieser wurde mittels CoqIde ausgeführt und in den Dateien \textbf{paperimpl.ml} und \textbf{paperimpl.mli} gespeichert. \textbf{.ml} enthält dabei die Programmlogik und \textbf{.mli} ist eine Header-Datei, welche diese Logik beschreibt.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code Resultat (paperimpl.ml),label=lst:practical-generated-code]
type natprod =
| Pair of int * int

(** val fst : natprod -> int **)

let fst = function
| Pair (x, _) -> x

(** val snd : natprod -> int **)

let snd = function
| Pair (_, y) -> y

(** val swap_pair : natprod -> natprod **)

let swap_pair = function
| Pair (x, y) -> Pair (y, x)
\end{lstlisting}
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code Resultat (paperimpl.mli),label=lst:practical-generated-code-header]
type natprod =
| Pair of int * int

val fst : natprod -> int

val snd : natprod -> int

val swap_pair : natprod -> natprod
\end{lstlisting}
Dadurch dass der Coq-To-Ocaml-Extraktor nicht komplett formal verifiziert ist, kann es sein, dass der Code nicht zu 100\% korrekt ist. Um die Korrektheit sicherzustellen, wurde im Nachhinein ein paar Tests in Ocaml geschrieben, welche im Codebeispiel \ref{lst:practical-code-adjustment} dargestellt werden. Diese Tests beschreiben einfache Funktionsaufrufe, wie zum Beispiel das Erhalten des ersten und zweiten Wertes eines Paares in Zeile 2 und 3. Anschließend werden dieselben Funktionen noch einmal aufgerufen - allerdings auf ein neues Paar (Zeile 8-10), dass durch die \textbf{swap\_pair} Funktion entstanden ist. Zur Nachvollziehbarkeit werden dabei die jeweiligen Ergebnisse auf der Kommandozeile ausgegeben.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code testen (paperimpl.ml),label=lst:practical-code-adjustment]
let pair = Pair(3, 4);;
let resultfst = fst pair;;
let resultsnd = snd pair;;

Printf.printf "Result fst: %d \n%!" resultfst;;
Printf.printf "Result snd: %d \n%!" resultsnd;;

let pair2 = swap_pair pair;;
let resultfst2 = fst pair2;;
let resultsnd2 = snd pair2;;

Printf.printf "Result fst: %d \n%!" resultfst2;;
Printf.printf "Result snd: %d \n%!" resultsnd2;;
\end{lstlisting}
Ocaml-Code muss genauso wie Coq- und C-Code compiliert werden. Folgender Befehl in Codebeispiel \ref{lst:practical-code-compilation} ermöglicht es aus der \textbf{paperimpl.ml} und der \textbf{paperimpl.mli} Datei funktionierenden compilierten Code zu erhalten. Dieser wird unter dem Namen \textbf{paperimp} im selben Verzeichnis abgelegt.
\\
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code compilieren,label=lst:practical-code-compilation]
ocamlc -w -20 -w -26 -o paperimp paperimpl.mli paperimpl.ml
\end{lstlisting}

In Codeblock \ref{lst:practical-code-execution} werden die Ausgaben der Tests dargestellt. Die ersten zwei Zeilen zeigen den x- und y- Wert eines Paares, dass durch \textbf{x: 3} und \textbf{y: 4} initialisiert wurde. Die Ausgaben in Zeile 4 und 5 stellen \textbf{fst} und \textbf{snd} des invertierten Paars dar.
\begin{lstlisting}[language=coq,firstnumber=1,caption=Ocaml Code ausführen,label=lst:practical-code-execution]
lukas@luk-ubuntu@~/Documents/coq-test/lf: ./paperimp
Result fst: 3 
Result snd: 4 
Result fst: 4 
Result snd: 3 
\end{lstlisting}

\subsection{Programm -> Proof}
Die folgenden Unterkapitel erläutern den theoretischen und praktischen Weg, um Programmcode im Nachhinein mit Coq zu verifizieren. Dies wird anhand von der Programmiersprache C erläutert. Dabei wird die \textbf{Verified Software Toolchain (VST)}, auch Princeton Tool Chain genannt, verwendet, welche von Forschern von INRIA und der Princeton University entwickelt wurde.

\subsubsection{Beispiel Programmiersprache C und VST}
Ein C-Programm kann nicht einfach in Coq kopiert und anschließend bewiesen werden. Dafür wird das Hilfsmittel \textbf{VST} benötigt. Diese ermöglicht es, ein C-Programm über \textbf{Verifiable C} in verifizierten Maschinencode zu übersetzen.
In folgender Abbildung \ref{fig:vst} sind die einzelnen Komponenten von der VST zu sehen.

\begin{minipage}{\textwidth}
	\centering
	\captionsetup{type=figure}
	\includegraphics[width=0.6\textwidth]{\figdir/VST-diagram.jpg}
	\caption{Verified Software Toolchain\cite{PRINCETON01:VST}}
	\label{fig:vst}
\end{minipage}

Zuerst wird dabei das C-Source-Programm in Verifiable C übersetzt.
"`Verifiable C ist grundsätzlich korrekt. Das heißt, es ist nachgewiesen (mit einem maschinell geprüften Beweis im Coq-Proof-Assistenten), dass:\\
\textbf{Egal welche beobachtbare Eigenschaft eines C-Programms Sie auch immer beweisen wollen. Unter Verwendung der Verifiable C-Programmlogik, wird diese Eigenschaft
tatsächlich im Assemblerprogramm enthalten sein, welches der C-Compiler generiert.}"'(übersetzt aus \cite{Appel02:VST})\\
Mit \textbf{program logic} ist eine Art Hoare Logik gemeint, die ein leichteres Beweisen von Programmcode mit Pointern, Funktions-Pointern, Datenabstraktion und Datenstrukturen ermöglicht.\cite{Appel02:VST} Die Hoare Logik wurde durch den britischen Informatiker C. A. R. Hoare entwickelt und dient generell als Hilfsmittel für das Beweisen von Programmcode. Dabei werden logische Regeln aufgestellt, die es erlauben Aussage in mathematischer Form über Computer-Programme zu treffen.\\
Die in orange dargestellte Komponente \textbf{VST retargetable Separation Logic} ergänzt die \textbf{program logic}. Außerdem können dadurch zusätzliche \textbf{verified program analysis tools} integriert werden.\\
\\
Der nächste Schritt in der Princeton Tool Chain ist der \textbf{verified Compiler CompCert}. Dieser wurde ebenfalls von INRIA entwickelt und ist wie die VST open-source auf GitHub erhältlich unter \url{https://github.com/PrincetonUniversity/VST} und \url{https://github.com/PrincetonUniversity/VST/tree/master/compcert}. 
CompCert wandelt schlussendlich den Verifiable C Code in Maschinensprache um.
Der Compiler CompCert ist bereits komplett formal durch Coq verifiziert. Dies bedeutet, dass jeder in Verifiable C geschriebene Programmcode korrekt in den entsprechenden verifizierten Assemblercode übersetzt wird. Es stellt sich die Frage, wie und wo die selbstgeschriebenen Funktionen auf mathematische Korrektheit geprüft werden.

\subsubsection{Benutzung VST}
Das Vorgehen zur Überprüfung der mathematischen Korrektheit von selbst geschriebenen C-Code ist im Paper "`\textbf{Verifiable C} Applying the Verified Software Toolchain to C programs"' beschrieben.\cite{Appel01:VST}\\
Zuerst muss ein C-Programm beispielsweise in einer Datei \textbf{F.c} vorhanden sein. Anschließend muss der normale C-Code mit Hilfe von VST in Verifiable C übersetzt werden. Dies ist mit Hilfe des Command Line Interface (CLI) Kommandos \textbf{clightgen -normalize F.c} möglich. Dadurch entsteht eine Coq-Datei \textbf{F.v}. Um die enthaltenen Funktionen zu beweisen, muss eine Datei mit beispielsweise dem Namen \textbf{verif\_F.v} erstellt werden. Wichtig dabei ist, dass in der Datei sowohl \textbf{F.v} als auch das VST Floyd Programm-Verifikationssystem \textbf{VST.floyd.proofauto} importiert werden (siehe Codebeispiel \ref{lst:practical-proof-extraction} für Import). Wenn ein Beweisen in der Datei \textbf{verif\_F.v} aller Funktionen gelingt, ist das C-Programm korrekt geschrieben, kann kompiliert werden und ist somit maschinell formal verifiziert.


\section{Aktuelle Anwendung}
\label{s:current-usage}
In diesem Kapitel werden einige Anwendungsfälle und Projekte kurz vorgestellt.

\subsection{Proofed Stack}
Mit Hilfe von VST inklusive CompCert wird versucht eine Art Stack aufzubauen, der von Maschinensprache über das Betriebssystem bis hin zu C-Programmcode formal verifiziert ist. Hierfür wird zusätzlich ein spezielles Coq-Framework namens \textbf{Kami} verwendet. Damit ist es möglich Hardware-Design formal zu beweisen. Diese Domain Specific Language (DSL) ist hauptsächlich inspiriert von \textbf{Bluespec} und der open-source \textbf{RISC-V} Befehlssatzarchitektur.\cite{KAMI01:ST} Vereinfacht gesagt, beschreibt dies die Verhaltensweise eines Prozessors in Form von einer formalen Spezifikation.\\
Die zur Architektur passenden Chips werden beispielsweise durch \textbf{SiFive}, welche auch \textbf{Kami} entwickelt haben, hergestellt.\\
Schlussendlich fehlt noch ein Betriebssystem, welches zum ein oder anderen Zeitpunkt mit Prozessoren und Speichern interagiert. Hierfür wurde \textbf{CertiKOS}, das erste formal verifizierte Betriebssystem, entwickelt. Es unterstützt \textbf{x86} inklusive Multiprocessing. Außerdem ist es möglich, einen Hypervisor zu hosten und dadurch mehrere Betriebssysteme gleichzeitig auf der selben Maschine zu verwenden.\cite{CERTIKOS01:FV}\cite{CERTIKOS02:FV}\\
\\
Der ganze Proofed Stack könnte ungefähr in den Ebenen wie in der folgenden Illustration \ref{fig:proofed-stack} dargestellt werden. Dabei sind Hardware-Komponenten in rot markiert. Der Softwareteil wird farblich unterschiedlich abgebildet mit dem Ziel, dass das Bild übersichtlicher ist.\\


\begin{minipage}{\textwidth}
	\centering
	\captionsetup{type=figure}
	\includegraphics[width=0.6\textwidth]{\figdir/verified-stack.png}
	\caption{Proofed Stack}
	\label{fig:proofed-stack}
\end{minipage}


\subsection{JSCert}
JSCert ist eine maschinell in Coq geprüfte Spezifikation von JavaScript. Es wurde mit der Coq Version 8.4.6 geschrieben. Dabei wurde versucht, sich so nah wie möglich am englischen Standard ECMAScript 5 zu halten. Des Weiteren ist ein in Ocaml geschriebener Interpreter namens \textbf{JSRef} damit als korrekt bewiesen worden. Dies deckt 262 Testfälle ab.\cite{JSCERT01:FV}\cite{JSCERT012:FV}

\subsection{CertiCoq}
CertiCoq ist ein in Coq verifizierter Compiler für Coq. Genau genommen beweist CertiCoq, dass die Kompilierung von typ-abhängigen Sprachen, wie Gallina korrekt verläuft.\cite{CERTICOQ01:FV}\cite{CERTICOQ02:FV}

\subsection{Beweise für Probleme der Mathematik oder Informatik}
Mit Coq kann nicht nur Programmcode verifiziert werden. Die Grundlage dafür sind schließlich mathematische Beweise inklusive Taktiken und der interaktiven Entwicklungsumgebung. Somit wird Coq auch von Theoretikern, welche vor allem aus den Fachbereichen der Mathematik und Informatik kommen, genutzt. Die folgenden zwei bekannten Probleme wurden mittels Coq bewiesen. 

\subsubsection{Satz von Feit-Thompson}
Das Odd-Order-Theorem, zu Deutsch Satz von Feit-Thompson sagt aus, dass jede endliche Gruppe von ungeraden Ordnungen auflösbar ist. Dies wurde bereits durch Walter Feit und John Griggs Thompson 1963 bewiesen.\cite{ODD01:FV}\\
Nach einer sechsjährigen Arbeit gelang Georges Gonthier von INRIA 2012 die Verifikation in Coq. Dies wurde als Forschungs-Projekt zur Weiterentwicklung von Coq durchgeführt. Dabei sind über 150.000 Zeilen an Beweis-Code entstanden, welche circa 4.000 Definitionen und 13.000 Theoreme enthalten.\cite{ODD01:FV}

\subsubsection{Vier-Farben-Theorem}
Das Vier-Farben Theorem sagt aus, dass es immer möglich ist, mit Hilfe von vier Farben eine beliebige Landkarte in der euklidischen Ebene einzufärben. Dabei dürfen angrenzende Länder niemals gleich gefärbt sein. Weiterhin werden isolierte gemeinsame Punkte nicht als Grenze gewertet. Eine weitere Einschränkung ist, dass keine Exklaven vorhanden sein dürfen. Dies bedeutet, dass die Karte aus einer zusammenhängenden Fläche bestehen muss (siehe Abbildung \ref{fig:four-color}).\cite{FOURCOLORS01:FV}\\
Im Jahr 2005 wurde dieses Theorem erstmals durch die zwei Forscher Georges Gonthier und Benjamin Werner vollständig mit Coq bewiesen.
\cite{FOURCOLORS02:FV}\\

\begin{minipage}{\textwidth}
	\centering
	\captionsetup{type=figure}
	\includegraphics[width=0.3\textwidth]{\figdir/four-color.png}
	\caption{Beispiel für Vier-Farben-Problem}
	\label{fig:four-color}
\end{minipage}

\section{Aufwand in der Praxis}
Der Aufwand für formale Verifikation ist schwer abzuschätzen, da diese Art des Programmierens nicht für jedes Teilgebiet ausreichend erforscht ist oder überhaupt benötigt wird. Grundsätzlich nutzen vor allem große Firmen im Bereich der low-level Software diese Form der Verifizierung. Damit kann beispielsweise sichergestellt werden, dass ein Prozessor immer korrekt angesteuert wird et cetera. Dabei werden meist funktionale Sprachen, wie C oder maschinennahe Sprachen verwendet. Im
Vergleich zu anderen Programmiersprachen wie Java oder C\#, ist in diesen Bereichen die Forschung bereits sehr weit vorgedrungen.\\
\\
In einem Vortrag über das Projekt Ironclad von Microsoft Research sprach Bryan Parno 2014 über den Einsatz von Formaler Verifikation bei einer Ende-zu-Ende Sicherheits-Anwendung. Dabei benannte er den Aufwand für das Programmieren mit etwa fünf Zeilen extra Beweis-Code pro Zeile Programmcode. Außerdem sei es eine komplett neue Art Software zu entwickeln. Abschließend fügte er noch hinzu, dass der meiste neue Code "`out-of-the-box"' funktionierte und faktisch kaum Bugs enthielt.\cite{IRONCLAD01:FV}

\section{Fazit}

\subsection{Zusammenfassung}
Diese Arbeit stellt die Grundlagen der formalen Verifikation, welche auf Programmcode angewendet werden kann, vor. Dabei wird zuerst auf die Relevanz eingegangen. Weitere Kapitel führen den Leser in maschinelles Beweisen mit Hilfe von Coq und der CoqIde ein. Das Herzstück dieser Arbeit ist die Programmcodeverifikation, welche auf zwei Wegen durchführbar ist. Einerseits kann zuerst ein Beweis für ein Theorem geschrieben und anschließend extrahiert werden. Andererseits ist es auch möglich, geschriebenen Programmcode im Nachhinein formal zu verifizieren. Beides wird in dieser Arbeit sowohl theoretisch als auch praktisch erläutert. Die Extraktion von Beweisen in Ocaml Code wird dabei anhand eines konkreten Codebeispiels detaillierter beschrieben. Abschließend werden konkrete Anwendungsfälle von formaler Verifikation mit Coq und eine Aufwandsschätzung für dessen praktische Anwendung präsentiert.

\subsection{Schlussfolgerung}

Programmcodeverifikation ist zum aktuellen Zeitpunkt ein weniger bekanntes Thema in der Informatik. Weil es damit möglich ist 100\% korrekte Software zu entwickeln, setzten vor allem große Firmen, die sicherheitskritische oder viel verwendete Systeme bauen, auf diese Technologie. Der Aufwand für formal verifizierte Software ist dabei vergleichsweise deutlich höher. Entwickler von Microsoft Research schätzen den Aufwand auf circa 5 Zeilen Beweis-Code für jede Zeile Programmcode basierend auf ihrem durchgeführten Forschungsprojekt Ironclad. Außerdem nannten sie es eine neue Art für die Entwicklung der Software. Der Programmcode funktionierte meistens bereits beim ersten Mal und enthielt nur wenige Fehler. Dies kann durch das spezielle Typ-System von Coq, den dependent Types, erzielt werden. Dadurch sind Checks auf korrekten Code, welche normalerweise erst bei der Laufzeit passieren, bereits bei der Compilierung durchführbar.\\
Obwohl ein zu 100\% funktionierender Programmcode in jedem Fachbereich ideal wäre, stehen Aufwand und Kosten nicht immer im passenden Verhältnis zum gewonnenen Nutzen.
Des Weiteren ist zur erwähnen, dass nur eine gute Spezifikation zu gutem Code führt. Mit Hilfe der formalen Verifikation kann zwar bewiesen werden, dass der Programmcode der Spezifikation entspricht, allerdings nicht, ob die Spezifikation selbst richtig ist.
Dadurch, dass eine Software immer auf Hardware läuft, kann zusätzlich keine wirkliche 100\%-tige Korrektheit eines Systems mit verifizierter Software garantiert werden. Hardware ist immer ab einem gewissen Zeitpunkt fehlbar und muss komplett ausgetauscht oder repariert werden.\\
Zusammenfassend wird Coq und formale Verifikation von Programmcode als sehr interessantes Thema mit viel Potential durch den Autor dieser Arbeit bewertet. Weiterführende Artikel, Talks und anderweitige Quellen sind im Kapitel \ref{a:append} des Anhangs zu finden. 

\section{Glossar}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis.tex"
%%% End: 
